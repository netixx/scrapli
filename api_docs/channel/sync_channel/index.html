
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Scrapli: fast, flexible, sync or async, telnet/ssh/netconf">
      
      
      
        <meta name="author" content="Carl Montanari">
      
      
        <link rel="canonical" href="https://github.com/carlmontanari/scrapli/api_docs/channel/sync_channel/">
      
      <link rel="shortcut icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.2.5">
    
    
      
        <title>Sync Channel - Scrapli</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.15aa0b43.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.75751829.min.css">
        
          
          
          <meta name="theme-color" content="#000000">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="black" data-md-color-accent="teal">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module-scraplichannelsync_channel" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="https://github.com/carlmontanari/scrapli" title="Scrapli" class="md-header-nav__button md-logo" aria-label="Scrapli">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            Scrapli
          </span>
        </div>
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            
              Sync Channel
            
          </span>
        </div>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/carlmontanari/scrapli" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
  </div>
  <div class="md-source__repository">
    carlmontanari/scrapli
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://github.com/carlmontanari/scrapli" title="Scrapli" class="md-nav__button md-logo" aria-label="Scrapli">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Scrapli
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/carlmontanari/scrapli" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
  </div>
  <div class="md-source__repository">
    carlmontanari/scrapli
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Scrapli
      </a>
    </li>
  

    
      
      
      


  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" >
      
      <label class="md-nav__link" for="nav-2">
        User Guide
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="User Guide" data-md-level="1">
        <label class="md-nav__title" for="nav-2">
          <span class="md-nav__icon md-icon"></span>
          User Guide
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../user_guide/quickstart/" class="md-nav__link">
        Quick Start Guide
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../user_guide/project_details/" class="md-nav__link">
        Project Details
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../user_guide/versioning/" class="md-nav__link">
        Versioning
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../user_guide/installation/" class="md-nav__link">
        Installation
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../user_guide/basic_usage/" class="md-nav__link">
        Basic Usage
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../user_guide/advanced_usage/" class="md-nav__link">
        Advanced Usage
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../user_guide/linting_testing/" class="md-nav__link">
        Linting and Testing
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../user_guide/faq/" class="md-nav__link">
        FAQ
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      


  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
      
      <label class="md-nav__link" for="nav-3">
        API Docs
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="API Docs" data-md-level="1">
        <label class="md-nav__title" for="nav-3">
          <span class="md-nav__icon md-icon"></span>
          API Docs
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../public_api_status/" class="md-nav__link">
        Public API Status
      </a>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2" type="checkbox" id="nav-3-2" >
      
      <label class="md-nav__link" for="nav-3-2">
        Driver
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Driver" data-md-level="2">
        <label class="md-nav__title" for="nav-3-2">
          <span class="md-nav__icon md-icon"></span>
          Driver
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/base_driver/" class="md-nav__link">
        Base Driver Arguments
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/generic_driver/" class="md-nav__link">
        Generic Driver Arguments
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/network_driver/" class="md-nav__link">
        Network Driver Arguments
      </a>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-4" type="checkbox" id="nav-3-2-4" >
      
      <label class="md-nav__link" for="nav-3-2-4">
        Base
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Base" data-md-level="3">
        <label class="md-nav__title" for="nav-3-2-4">
          <span class="md-nav__icon md-icon"></span>
          Base
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/base/base_driver/" class="md-nav__link">
        Base Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/base/sync_driver/" class="md-nav__link">
        Sync Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/base/async_driver/" class="md-nav__link">
        Async Driver
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-5" type="checkbox" id="nav-3-2-5" >
      
      <label class="md-nav__link" for="nav-3-2-5">
        Generic
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Generic" data-md-level="3">
        <label class="md-nav__title" for="nav-3-2-5">
          <span class="md-nav__icon md-icon"></span>
          Generic
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/generic/base_driver/" class="md-nav__link">
        Base Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/generic/sync_driver/" class="md-nav__link">
        Sync Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/generic/async_driver/" class="md-nav__link">
        Async Driver
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-6" type="checkbox" id="nav-3-2-6" >
      
      <label class="md-nav__link" for="nav-3-2-6">
        Network
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Network" data-md-level="3">
        <label class="md-nav__title" for="nav-3-2-6">
          <span class="md-nav__icon md-icon"></span>
          Network
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/network/base_driver/" class="md-nav__link">
        Base Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/network/sync_driver/" class="md-nav__link">
        Sync Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/network/async_driver/" class="md-nav__link">
        Async Driver
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-7" type="checkbox" id="nav-3-2-7" >
      
      <label class="md-nav__link" for="nav-3-2-7">
        Core
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Core" data-md-level="3">
        <label class="md-nav__title" for="nav-3-2-7">
          <span class="md-nav__icon md-icon"></span>
          Core
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-7-1" type="checkbox" id="nav-3-2-7-1" >
      
      <label class="md-nav__link" for="nav-3-2-7-1">
        Arista EOS
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Arista EOS" data-md-level="4">
        <label class="md-nav__title" for="nav-3-2-7-1">
          <span class="md-nav__icon md-icon"></span>
          Arista EOS
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/arista_eos/base_driver/" class="md-nav__link">
        Base Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/arista_eos/sync_driver/" class="md-nav__link">
        Sync Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/arista_eos/async_driver/" class="md-nav__link">
        Async Driver
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-7-2" type="checkbox" id="nav-3-2-7-2" >
      
      <label class="md-nav__link" for="nav-3-2-7-2">
        Cisco IOSXE
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Cisco IOSXE" data-md-level="4">
        <label class="md-nav__title" for="nav-3-2-7-2">
          <span class="md-nav__icon md-icon"></span>
          Cisco IOSXE
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_iosxe/base_driver/" class="md-nav__link">
        Base Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_iosxe/sync_driver/" class="md-nav__link">
        Sync Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_iosxe/async_driver/" class="md-nav__link">
        Async Driver
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-7-3" type="checkbox" id="nav-3-2-7-3" >
      
      <label class="md-nav__link" for="nav-3-2-7-3">
        Cisco IOSXR
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Cisco IOSXR" data-md-level="4">
        <label class="md-nav__title" for="nav-3-2-7-3">
          <span class="md-nav__icon md-icon"></span>
          Cisco IOSXR
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_iosxr/base_driver/" class="md-nav__link">
        Base Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_iosxr/sync_driver/" class="md-nav__link">
        Sync Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_iosxr/async_driver/" class="md-nav__link">
        Async Driver
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-7-4" type="checkbox" id="nav-3-2-7-4" >
      
      <label class="md-nav__link" for="nav-3-2-7-4">
        Cisco NXOS
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Cisco NXOS" data-md-level="4">
        <label class="md-nav__title" for="nav-3-2-7-4">
          <span class="md-nav__icon md-icon"></span>
          Cisco NXOS
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_nxos/base_driver/" class="md-nav__link">
        Base Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_nxos/sync_driver/" class="md-nav__link">
        Sync Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/cisco_nxos/async_driver/" class="md-nav__link">
        Async Driver
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-2-7-5" type="checkbox" id="nav-3-2-7-5" >
      
      <label class="md-nav__link" for="nav-3-2-7-5">
        Juniper Junos
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Juniper Junos" data-md-level="4">
        <label class="md-nav__title" for="nav-3-2-7-5">
          <span class="md-nav__icon md-icon"></span>
          Juniper Junos
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/juniper_junos/base_driver/" class="md-nav__link">
        Base Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/juniper_junos/sync_driver/" class="md-nav__link">
        Sync Driver
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../driver/core/juniper_junos/async_driver/" class="md-nav__link">
        Async Driver
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-3" type="checkbox" id="nav-3-3" checked>
      
      <label class="md-nav__link" for="nav-3-3">
        Channel
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Channel" data-md-level="2">
        <label class="md-nav__title" for="nav-3-3">
          <span class="md-nav__icon md-icon"></span>
          Channel
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../base_channel/" class="md-nav__link">
        Base Channel
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Sync Channel
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Sync Channel
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#channel" class="md-nav__link">
    Channel
  </a>
  
    <nav class="md-nav" aria-label="Channel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    Methods
  </a>
  
    <nav class="md-nav" aria-label="Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#channel_authenticate_ssh" class="md-nav__link">
    channel_authenticate_ssh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#channel_authenticate_telnet" class="md-nav__link">
    channel_authenticate_telnet
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_prompt" class="md-nav__link">
    get_prompt
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#read" class="md-nav__link">
    read
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#send_input" class="md-nav__link">
    send_input
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#send_input_and_read" class="md-nav__link">
    send_input_and_read
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#send_inputs_interact" class="md-nav__link">
    send_inputs_interact
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../async_channel/" class="md-nav__link">
        Async Channel
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-4" type="checkbox" id="nav-3-4" >
      
      <label class="md-nav__link" for="nav-3-4">
        Transports
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Transports" data-md-level="2">
        <label class="md-nav__title" for="nav-3-4">
          <span class="md-nav__icon md-icon"></span>
          Transports
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-4-1" type="checkbox" id="nav-3-4-1" >
      
      <label class="md-nav__link" for="nav-3-4-1">
        Base
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Base" data-md-level="3">
        <label class="md-nav__title" for="nav-3-4-1">
          <span class="md-nav__icon md-icon"></span>
          Base
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/base/base_transport/" class="md-nav__link">
        Base Transport
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/base/sync_transport/" class="md-nav__link">
        Sync Transport
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/base/async_transport/" class="md-nav__link">
        Async Transport
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/base/socket/" class="md-nav__link">
        Socket
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3-4-2" type="checkbox" id="nav-3-4-2" >
      
      <label class="md-nav__link" for="nav-3-4-2">
        Plugins
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Plugins" data-md-level="3">
        <label class="md-nav__title" for="nav-3-4-2">
          <span class="md-nav__icon md-icon"></span>
          Plugins
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/plugins/asyncssh/" class="md-nav__link">
        Asyncssh
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/plugins/asynctelnet/" class="md-nav__link">
        Asynctelnet
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/plugins/paramiko/" class="md-nav__link">
        Paramiko
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/plugins/ssh2/" class="md-nav__link">
        SSH2
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/plugins/system/" class="md-nav__link">
        System
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../transport/plugins/telnet/" class="md-nav__link">
        Telnet
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../decorators/" class="md-nav__link">
        Decorators
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../exceptions/" class="md-nav__link">
        Exceptions
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../factory/" class="md-nav__link">
        Factory
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../helper/" class="md-nav__link">
        Helper
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../logging/" class="md-nav__link">
        Logging
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../response/" class="md-nav__link">
        Response
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../ssh_config/" class="md-nav__link">
        SSH Config
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      


  
  
  
    <li class="md-nav__item">
      <a href="../../../changelog/" class="md-nav__link">
        Changelog
      </a>
    </li>
  

    
      
      
      


  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" >
      
      <label class="md-nav__link" for="nav-5">
        More Scrapli
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="More Scrapli" data-md-level="1">
        <label class="md-nav__title" for="nav-5">
          <span class="md-nav__icon md-icon"></span>
          More Scrapli
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../more_scrapli/nornir_scrapli/" class="md-nav__link">
        Nornir Scrapli
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../more_scrapli/scrapli_community/" class="md-nav__link">
        Scrapli Community
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../more_scrapli/scrapli_netconf/" class="md-nav__link">
        Scrapli Netconf
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../more_scrapli/scrapli_stubs/" class="md-nav__link">
        Scrapli Stubs
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      


  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6" >
      
      <label class="md-nav__link" for="nav-6">
        Other
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Other" data-md-level="1">
        <label class="md-nav__title" for="nav-6">
          <span class="md-nav__icon md-icon"></span>
          Other
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../about/contributing/" class="md-nav__link">
        Contributing
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../about/code_of_conduct/" class="md-nav__link">
        Code of Conduct
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../../about/thank_you/" class="md-nav__link">
        Thank Yous
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#channel" class="md-nav__link">
    Channel
  </a>
  
    <nav class="md-nav" aria-label="Channel">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    Methods
  </a>
  
    <nav class="md-nav" aria-label="Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#channel_authenticate_ssh" class="md-nav__link">
    channel_authenticate_ssh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#channel_authenticate_telnet" class="md-nav__link">
    channel_authenticate_telnet
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_prompt" class="md-nav__link">
    get_prompt
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#read" class="md-nav__link">
    read
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#send_input" class="md-nav__link">
    send_input
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#send_input_and_read" class="md-nav__link">
    send_input_and_read
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#send_inputs_interact" class="md-nav__link">
    send_inputs_interact
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <p><link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin></p>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>

<h1 id="module-scraplichannelsync_channel">Module scrapli.channel.sync_channel<a class="headerlink" href="#module-scraplichannelsync_channel" title="Permanent link">&para;</a></h1>
<p>scrapli.channel.sync_channel</p>
<details class="source">
    <summary>
        <span>Expand source code</span>
    </summary>
    <pre>
        <code class="python">
"""scrapli.channel.sync_channel"""
import re
import time
from contextlib import contextmanager
from datetime import datetime
from threading import Lock
from typing import Iterator, List, Optional, Tuple

from scrapli.channel.base_channel import BaseChannel, BaseChannelArgs
from scrapli.decorators import ChannelTimeout
from scrapli.exceptions import ScrapliAuthenticationFailed, ScrapliTimeout
from scrapli.transport.base import Transport


class Channel(BaseChannel):
    def __init__(
        self,
        transport: Transport,
        base_channel_args: BaseChannelArgs,
    ) -> None:
        super().__init__(
            transport=transport,
            base_channel_args=base_channel_args,
        )
        self.transport: Transport

        self.channel_lock: Optional[Lock] = None
        if self._base_channel_args.channel_lock:
            self.channel_lock = Lock()

    @contextmanager
    def _channel_lock(self) -> Iterator[None]:
        """
        Lock the channel during public channel operations if channel_lock is enabled

        Args:
            N/A

        Yields:
            None

        Raises:
            N/A

        """
        if self.channel_lock:
            with self.channel_lock:
                yield
        else:
            yield

    def read(self) -> bytes:
        """
        Read chunks of output from the channel

        Replaces any r"\r" characters that sometimes get stuffed into the output from the devices

        Args:
            N/A

        Returns:
            bytes: output read from channel

        Raises:
            N/A

        """
        buf = self.transport.read()
        buf = buf.replace(b"\r", b"")

        self.logger.debug(f"read: {repr(buf)}")

        if self.channel_log:
            self.channel_log.write(buf)

        if self._base_channel_args.comms_ansi:
            buf = self._strip_ansi(buf=buf)

        return buf

    def _read_until_input(self, channel_input: bytes) -> bytes:
        """
        Read until all channel_input has been read on the channel

        Args:
            channel_input: bytes that should have been written to the channel

        Returns:
            bytes: output read from channel while checking for the input in the channel stream

        Raises:
            N/A

        """
        buf = b""

        if not channel_input:
            return buf

        # squish all channel input words together and cast to lower to make comparison easier
        processed_channel_input = b"".join(channel_input.lower().split())

        while True:
            buf += self.read()

            # replace any backspace chars (particular problem w/ junos), and remove any added spaces
            # this is just for comparison of the inputs to what was read from channel
            if processed_channel_input in b"".join(buf.lower().replace(b"\x08", b"").split()):
                return buf

    def _read_until_prompt(self, buf: bytes = b"", prompt: str = "") -> bytes:
        """
        Read until expected prompt is seen

        Args:
            buf: output from previous reads if needed (used in scrapli netconf)
            prompt: prompt to look for if not looking for base prompt (comms_prompt_pattern)

        Returns:
            bytes: output read from channel

        Raises:
            N/A

        """
        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern, pattern=prompt
        )

        while True:
            buf += self.read()

            channel_match = re.search(
                pattern=search_pattern,
                string=buf,
            )

            if channel_match:
                return buf

    def _read_until_prompt_or_time(
        self,
        buf: bytes = b"",
        channel_outputs: Optional[List[bytes]] = None,
        read_duration: Optional[float] = None,
    ) -> bytes:
        """
        Read until expected prompt is seen, outputs are seen, or for duration, whichever comes first

        As transport reading may block, transport timeout is temporarily set to the read_duration
        and any `ScrapliTimeout` that is raised while reading is ignored.

        Args:
            buf: bytes from previous reads if needed
            channel_outputs: List of bytes to search for in channel output, if any are seen, return
                read output
            read_duration: duration to read from channel for

        Returns:
            bytes: output read from channel

        Raises:
            N/A

        """
        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern,
        )

        if channel_outputs is None:
            channel_outputs = []
        if read_duration is None:
            read_duration = 2.5

        regex_channel_outputs_pattern = self._join_and_compile(channel_outputs=channel_outputs)

        _transport_args = self.transport._base_transport_args  # pylint: disable=W0212
        previous_timeout_transport = _transport_args.timeout_transport
        _transport_args.timeout_transport = int(read_duration)

        start = time.time()
        while True:
            try:
                buf += self.read()
            except ScrapliTimeout:
                pass

            if (time.time() - start) > read_duration:
                break
            if any([channel_output in buf for channel_output in channel_outputs]):
                break
            if re.search(pattern=regex_channel_outputs_pattern, string=buf):
                break
            if re.search(pattern=search_pattern, string=buf):
                break

        _transport_args.timeout_transport = previous_timeout_transport

        return buf

    @ChannelTimeout(message="timed out during in channel ssh authentication")
    def channel_authenticate_ssh(
        self, auth_password: str, auth_private_key_passphrase: str
    ) -> None:
        """
        Handle SSH Authentication for transports that only operate "in the channel" (i.e. system)

        Args:
            auth_password: password to authenticate with
            auth_private_key_passphrase: passphrase for ssh key if necessary

        Returns:
            None

        Raises:
            ScrapliAuthenticationFailed: if password prompt seen more than twice
            ScrapliAuthenticationFailed: if passphrase prompt seen more than twice

        """
        self.logger.debug("attempting in channel ssh authentication")

        password_count = 0
        passphrase_count = 0
        authenticate_buf = b""

        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern
        )

        with self._channel_lock():
            while True:
                buf = self.read()

                # if user sets comms_ansi *or* if we see an escape char, strip ansi... at least eos
                # tends to have one escape char in the login output that will break things; other
                # than this and telnet login, stripping ansi will only ever be governed by the users
                # comms_ansi setting
                if self._base_channel_args.comms_ansi or b"\x1B" in buf:
                    buf = self._strip_ansi(buf=buf)

                authenticate_buf += buf.lower()

                self._ssh_message_handler(output=authenticate_buf)

                if b"password" in authenticate_buf:
                    # clear the authentication buffer so we don't re-read the password prompt
                    authenticate_buf = b""
                    password_count += 1
                    if password_count > 2:
                        msg = "password prompt seen more than once, assuming auth failed"
                        self.logger.critical(msg)
                        raise ScrapliAuthenticationFailed(msg)
                    self.write(channel_input=auth_password, redacted=True)
                    self.send_return()

                if b"enter passphrase for key" in authenticate_buf:
                    # clear the authentication buffer so we don't re-read the passphrase prompt
                    authenticate_buf = b""
                    passphrase_count += 1
                    if passphrase_count > 2:
                        msg = "passphrase prompt seen more than once, assuming auth failed"
                        self.logger.critical(msg)
                        raise ScrapliAuthenticationFailed(msg)
                    self.write(channel_input=auth_private_key_passphrase, redacted=True)
                    self.send_return()

                channel_match = re.search(
                    pattern=search_pattern,
                    string=authenticate_buf,
                )

                if channel_match:
                    return

    @ChannelTimeout(message="timed out during in channel telnet authentication")
    def channel_authenticate_telnet(self, auth_username: str = "", auth_password: str = "") -> None:
        """
        Handle Telnet Authentication

        Args:
            auth_username: username to use for telnet authentication
            auth_password: password to use for telnet authentication

        Returns:
            None

        Raises:
            ScrapliAuthenticationFailed: if password prompt seen more than twice
            ScrapliAuthenticationFailed: if login prompt seen more than twice

        """
        self.logger.debug("attempting in channel telnet authentication")

        username_count = 0
        password_count = 0
        authenticate_buf = b""

        # ignoring type here out of laziness mostly, telnet is kind of special and this should be
        # the only real one off type thing hopefully
        bytes_username_prompt = self.transport.username_prompt.encode()  # type: ignore
        bytes_password_prompt = self.transport.password_prompt.encode()  # type: ignore

        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern
        )

        # capture the start time of the authentication event; we also set a "return_interval" which
        # is 1/10 the timout_ops value, we will send a return character at roughly this interval if
        # there is no output on the channel. we do this because sometimes telnet needs a kick to get
        # it to prompt for auth -- particularity when connecting to terminal server/console port
        auth_start_time = datetime.now().timestamp()
        return_interval = self._base_channel_args.timeout_ops / 10
        return_attempts = 1

        with self._channel_lock():
            while True:
                buf = self.read()

                # telnet auth *probably* wont have ansi chars, but strip them if they do exist so
                # we can at least get past auth
                if self._base_channel_args.comms_ansi or b"\x1B" in buf:
                    buf = self._strip_ansi(buf=buf)

                if not buf:
                    current_iteration_time = datetime.now().timestamp()
                    if (current_iteration_time - auth_start_time) > (
                        return_interval * return_attempts
                    ):
                        self.send_return()
                        return_attempts += 1

                authenticate_buf += buf.lower()

                if bytes_username_prompt in authenticate_buf:
                    # clear the authentication buffer so we don't re-read the username prompt
                    authenticate_buf = b""
                    username_count += 1
                    if username_count > 2:
                        msg = "username/login prompt seen more than once, assuming auth failed"
                        self.logger.critical(msg)
                        raise ScrapliAuthenticationFailed(msg)
                    self.write(channel_input=auth_username)
                    self.send_return()

                if bytes_password_prompt in authenticate_buf:
                    # clear the authentication buffer so we don't re-read the password prompt
                    authenticate_buf = b""
                    password_count += 1
                    if password_count > 2:
                        msg = "password prompt seen more than once, assuming auth failed"
                        self.logger.critical(msg)
                        raise ScrapliAuthenticationFailed(msg)
                    self.write(channel_input=auth_password, redacted=True)
                    self.send_return()

                channel_match = re.search(
                    pattern=search_pattern,
                    string=authenticate_buf,
                )

                if channel_match:
                    return

    @ChannelTimeout(message="timed out getting prompt")
    def get_prompt(self) -> str:
        """
        Get current channel prompt

        Args:
            N/A

        Returns:
            str: string of the current prompt

        Raises:
            N/A

        """
        buf = b""

        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern
        )

        with self._channel_lock():
            self.send_return()

            while True:
                buf += self.read()

                channel_match = re.search(
                    pattern=search_pattern,
                    string=buf,
                )

                if channel_match:
                    current_prompt = channel_match.group(0)
                    return current_prompt.decode().strip()

    @ChannelTimeout(message="timed out sending input to device")
    def send_input(
        self,
        channel_input: str,
        *,
        strip_prompt: bool = True,
        eager: bool = False,
    ) -> Tuple[bytes, bytes]:
        """
        Primary entry point to send data to devices in shell mode; accept input and returns result

        Args:
            channel_input: string input to send to channel
            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)
            eager: eager mode reads and returns the `_read_until_input` value, but does not attempt
                to read to the prompt pattern -- this should not be used manually! (only used by
                `send_configs` with the eager flag set)

        Returns:
            Tuple[bytes, bytes]: tuple of "raw" output and "processed" (cleaned up/stripped) output

        Raises:
            N/A

        """
        self._pre_send_input(channel_input=channel_input)

        buf = b""
        bytes_channel_input = channel_input.encode()

        self.logger.info(
            f"sending channel input: {channel_input}; strip_prompt: {strip_prompt}; eager: {eager}"
        )

        with self._channel_lock():
            self.write(channel_input=channel_input)
            _buf_until_input = self._read_until_input(channel_input=bytes_channel_input)
            self.send_return()

            if not eager:
                buf += self._read_until_prompt()

        processed_buf = self._process_output(
            buf=buf,
            strip_prompt=strip_prompt,
        )
        return buf, processed_buf

    @ChannelTimeout(message="timed out sending input to device")
    def send_input_and_read(
        self,
        channel_input: str,
        *,
        strip_prompt: bool = True,
        expected_outputs: Optional[List[str]] = None,
        read_duration: Optional[float] = None,
    ) -> Tuple[bytes, bytes]:
        """
        Send a command and read until expected prompt is seen, outputs are seen, or for duration

        Args:
            channel_input: string input to send to channel
            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)
            expected_outputs: list of strings to look for in output; if any of these are seen,
                return output read up till that read
            read_duration: float duration to read for

        Returns:
            Tuple[bytes, bytes]: tuple of "raw" output and "processed" (cleaned up/stripped) output

        Raises:
            N/A

        """
        self._pre_send_input(channel_input=channel_input)

        buf = b""
        bytes_channel_input = channel_input.encode()
        bytes_channel_outputs = [
            channel_output.encode() for channel_output in expected_outputs or []
        ]

        self.logger.info(
            f"sending channel input and read: {channel_input}; strip_prompt: {strip_prompt}; "
            f"expected_outputs: {expected_outputs}; read_duration: {read_duration}"
        )

        with self._channel_lock():
            self.write(channel_input=channel_input)
            _buf_until_input = self._read_until_input(channel_input=bytes_channel_input)
            self.send_return()

            buf += self._read_until_prompt_or_time(
                channel_outputs=bytes_channel_outputs, read_duration=read_duration
            )

        processed_buf = self._process_output(
            buf=buf,
            strip_prompt=strip_prompt,
        )

        return buf, processed_buf

    @ChannelTimeout(message="timed out sending interactive input to device")
    def send_inputs_interact(
        self, interact_events: List[Tuple[str, str, Optional[bool]]]
    ) -> Tuple[bytes, bytes]:
        """
        Interact with a device with changing prompts per input.

        Used to interact with devices where prompts change per input, and where inputs may be hidden
        such as in the case of a password input. This can be used to respond to challenges from
        devices such as the confirmation for the command "clear logging" on IOSXE devices for
        example. You may have as many elements in the "interact_events" list as needed, and each
        element of that list should be a tuple of two or three elements. The first element is always
        the input to send as a string, the second should be the expected response as a string, and
        the optional third a bool for whether or not the input is "hidden" (i.e. password input)

        An example where we need this sort of capability:

        '''
        3560CX#copy flash: scp:
        Source filename []? test1.txt
        Address or name of remote host []? 172.31.254.100
        Destination username [carl]?
        Writing test1.txt
        Password:

        Password:
         Sink: C0644 639 test1.txt
        !
        639 bytes copied in 12.066 secs (53 bytes/sec)
        3560CX#
        '''

        To accomplish this we can use the following:

        '''
        interact = conn.channel.send_inputs_interact(
            [
                ("copy flash: scp:", "Source filename []?", False),
                ("test1.txt", "Address or name of remote host []?", False),
                ("172.31.254.100", "Destination username [carl]?", False),
                ("carl", "Password:", False),
                ("super_secure_password", prompt, True),
            ]
        )
        '''

        If we needed to deal with more prompts we could simply continue adding tuples to the list of
        interact "events".

        Args:
            interact_events: list of tuples containing the "interactions" with the device
                each list element must have an input and an expected response, and may have an
                optional bool for the third and final element -- the optional bool specifies if the
                input that is sent to the device is "hidden" (ex: password), if the hidden param is
                not provided it is assumed the input is "normal" (not hidden)

        Returns:
            Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning,
                and the output read from the channel that has been "cleaned up"

        Raises:
            N/A

        """
        self._pre_send_inputs_interact(interact_events=interact_events)

        buf = b""
        processed_buf = b""

        with self._channel_lock():
            for interact_event in interact_events:
                channel_input = interact_event[0]
                bytes_channel_input = channel_input.encode()
                channel_response = interact_event[1]
                try:
                    hidden_input = interact_event[2]
                except IndexError:
                    hidden_input = False

                _channel_input = channel_input if not hidden_input else "REDACTED"
                self.logger.info(
                    f"sending interactive input: {_channel_input}; "
                    f"expecting: {channel_response}; "
                    f"hidden_input: {hidden_input}"
                )

                self.write(channel_input=channel_input)
                if not channel_response or hidden_input is True:
                    self.send_return()
                else:
                    buf += self._read_until_input(channel_input=bytes_channel_input)
                    self.send_return()
                buf += self._read_until_prompt(prompt=channel_response)

        processed_buf += self._process_output(
            buf=buf,
            strip_prompt=False,
        )

        return buf, processed_buf
        </code>
    </pre>
</details>

<h2 id="classes">Classes<a class="headerlink" href="#classes" title="Permanent link">&para;</a></h2>
<h3 id="channel">Channel<a class="headerlink" href="#channel" title="Permanent link">&para;</a></h3>
<div class="text codehilite"><pre><span></span><code>BaseChannel Object -- provides convenience methods to both sync and async Channels

Args:
    transport: initialized scrapli Transport/AsyncTransport object
    base_channel_args: BaseChannelArgs object

Returns:
    None

Raises:
    N/A
</code></pre></div>

<details class="source">
    <summary>
        <span>Expand source code</span>
    </summary>
    <pre>
        <code class="python">
class Channel(BaseChannel):
    def __init__(
        self,
        transport: Transport,
        base_channel_args: BaseChannelArgs,
    ) -> None:
        super().__init__(
            transport=transport,
            base_channel_args=base_channel_args,
        )
        self.transport: Transport

        self.channel_lock: Optional[Lock] = None
        if self._base_channel_args.channel_lock:
            self.channel_lock = Lock()

    @contextmanager
    def _channel_lock(self) -> Iterator[None]:
        """
        Lock the channel during public channel operations if channel_lock is enabled

        Args:
            N/A

        Yields:
            None

        Raises:
            N/A

        """
        if self.channel_lock:
            with self.channel_lock:
                yield
        else:
            yield

    def read(self) -> bytes:
        """
        Read chunks of output from the channel

        Replaces any r"\r" characters that sometimes get stuffed into the output from the devices

        Args:
            N/A

        Returns:
            bytes: output read from channel

        Raises:
            N/A

        """
        buf = self.transport.read()
        buf = buf.replace(b"\r", b"")

        self.logger.debug(f"read: {repr(buf)}")

        if self.channel_log:
            self.channel_log.write(buf)

        if self._base_channel_args.comms_ansi:
            buf = self._strip_ansi(buf=buf)

        return buf

    def _read_until_input(self, channel_input: bytes) -> bytes:
        """
        Read until all channel_input has been read on the channel

        Args:
            channel_input: bytes that should have been written to the channel

        Returns:
            bytes: output read from channel while checking for the input in the channel stream

        Raises:
            N/A

        """
        buf = b""

        if not channel_input:
            return buf

        # squish all channel input words together and cast to lower to make comparison easier
        processed_channel_input = b"".join(channel_input.lower().split())

        while True:
            buf += self.read()

            # replace any backspace chars (particular problem w/ junos), and remove any added spaces
            # this is just for comparison of the inputs to what was read from channel
            if processed_channel_input in b"".join(buf.lower().replace(b"\x08", b"").split()):
                return buf

    def _read_until_prompt(self, buf: bytes = b"", prompt: str = "") -> bytes:
        """
        Read until expected prompt is seen

        Args:
            buf: output from previous reads if needed (used in scrapli netconf)
            prompt: prompt to look for if not looking for base prompt (comms_prompt_pattern)

        Returns:
            bytes: output read from channel

        Raises:
            N/A

        """
        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern, pattern=prompt
        )

        while True:
            buf += self.read()

            channel_match = re.search(
                pattern=search_pattern,
                string=buf,
            )

            if channel_match:
                return buf

    def _read_until_prompt_or_time(
        self,
        buf: bytes = b"",
        channel_outputs: Optional[List[bytes]] = None,
        read_duration: Optional[float] = None,
    ) -> bytes:
        """
        Read until expected prompt is seen, outputs are seen, or for duration, whichever comes first

        As transport reading may block, transport timeout is temporarily set to the read_duration
        and any `ScrapliTimeout` that is raised while reading is ignored.

        Args:
            buf: bytes from previous reads if needed
            channel_outputs: List of bytes to search for in channel output, if any are seen, return
                read output
            read_duration: duration to read from channel for

        Returns:
            bytes: output read from channel

        Raises:
            N/A

        """
        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern,
        )

        if channel_outputs is None:
            channel_outputs = []
        if read_duration is None:
            read_duration = 2.5

        regex_channel_outputs_pattern = self._join_and_compile(channel_outputs=channel_outputs)

        _transport_args = self.transport._base_transport_args  # pylint: disable=W0212
        previous_timeout_transport = _transport_args.timeout_transport
        _transport_args.timeout_transport = int(read_duration)

        start = time.time()
        while True:
            try:
                buf += self.read()
            except ScrapliTimeout:
                pass

            if (time.time() - start) > read_duration:
                break
            if any([channel_output in buf for channel_output in channel_outputs]):
                break
            if re.search(pattern=regex_channel_outputs_pattern, string=buf):
                break
            if re.search(pattern=search_pattern, string=buf):
                break

        _transport_args.timeout_transport = previous_timeout_transport

        return buf

    @ChannelTimeout(message="timed out during in channel ssh authentication")
    def channel_authenticate_ssh(
        self, auth_password: str, auth_private_key_passphrase: str
    ) -> None:
        """
        Handle SSH Authentication for transports that only operate "in the channel" (i.e. system)

        Args:
            auth_password: password to authenticate with
            auth_private_key_passphrase: passphrase for ssh key if necessary

        Returns:
            None

        Raises:
            ScrapliAuthenticationFailed: if password prompt seen more than twice
            ScrapliAuthenticationFailed: if passphrase prompt seen more than twice

        """
        self.logger.debug("attempting in channel ssh authentication")

        password_count = 0
        passphrase_count = 0
        authenticate_buf = b""

        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern
        )

        with self._channel_lock():
            while True:
                buf = self.read()

                # if user sets comms_ansi *or* if we see an escape char, strip ansi... at least eos
                # tends to have one escape char in the login output that will break things; other
                # than this and telnet login, stripping ansi will only ever be governed by the users
                # comms_ansi setting
                if self._base_channel_args.comms_ansi or b"\x1B" in buf:
                    buf = self._strip_ansi(buf=buf)

                authenticate_buf += buf.lower()

                self._ssh_message_handler(output=authenticate_buf)

                if b"password" in authenticate_buf:
                    # clear the authentication buffer so we don't re-read the password prompt
                    authenticate_buf = b""
                    password_count += 1
                    if password_count > 2:
                        msg = "password prompt seen more than once, assuming auth failed"
                        self.logger.critical(msg)
                        raise ScrapliAuthenticationFailed(msg)
                    self.write(channel_input=auth_password, redacted=True)
                    self.send_return()

                if b"enter passphrase for key" in authenticate_buf:
                    # clear the authentication buffer so we don't re-read the passphrase prompt
                    authenticate_buf = b""
                    passphrase_count += 1
                    if passphrase_count > 2:
                        msg = "passphrase prompt seen more than once, assuming auth failed"
                        self.logger.critical(msg)
                        raise ScrapliAuthenticationFailed(msg)
                    self.write(channel_input=auth_private_key_passphrase, redacted=True)
                    self.send_return()

                channel_match = re.search(
                    pattern=search_pattern,
                    string=authenticate_buf,
                )

                if channel_match:
                    return

    @ChannelTimeout(message="timed out during in channel telnet authentication")
    def channel_authenticate_telnet(self, auth_username: str = "", auth_password: str = "") -> None:
        """
        Handle Telnet Authentication

        Args:
            auth_username: username to use for telnet authentication
            auth_password: password to use for telnet authentication

        Returns:
            None

        Raises:
            ScrapliAuthenticationFailed: if password prompt seen more than twice
            ScrapliAuthenticationFailed: if login prompt seen more than twice

        """
        self.logger.debug("attempting in channel telnet authentication")

        username_count = 0
        password_count = 0
        authenticate_buf = b""

        # ignoring type here out of laziness mostly, telnet is kind of special and this should be
        # the only real one off type thing hopefully
        bytes_username_prompt = self.transport.username_prompt.encode()  # type: ignore
        bytes_password_prompt = self.transport.password_prompt.encode()  # type: ignore

        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern
        )

        # capture the start time of the authentication event; we also set a "return_interval" which
        # is 1/10 the timout_ops value, we will send a return character at roughly this interval if
        # there is no output on the channel. we do this because sometimes telnet needs a kick to get
        # it to prompt for auth -- particularity when connecting to terminal server/console port
        auth_start_time = datetime.now().timestamp()
        return_interval = self._base_channel_args.timeout_ops / 10
        return_attempts = 1

        with self._channel_lock():
            while True:
                buf = self.read()

                # telnet auth *probably* wont have ansi chars, but strip them if they do exist so
                # we can at least get past auth
                if self._base_channel_args.comms_ansi or b"\x1B" in buf:
                    buf = self._strip_ansi(buf=buf)

                if not buf:
                    current_iteration_time = datetime.now().timestamp()
                    if (current_iteration_time - auth_start_time) > (
                        return_interval * return_attempts
                    ):
                        self.send_return()
                        return_attempts += 1

                authenticate_buf += buf.lower()

                if bytes_username_prompt in authenticate_buf:
                    # clear the authentication buffer so we don't re-read the username prompt
                    authenticate_buf = b""
                    username_count += 1
                    if username_count > 2:
                        msg = "username/login prompt seen more than once, assuming auth failed"
                        self.logger.critical(msg)
                        raise ScrapliAuthenticationFailed(msg)
                    self.write(channel_input=auth_username)
                    self.send_return()

                if bytes_password_prompt in authenticate_buf:
                    # clear the authentication buffer so we don't re-read the password prompt
                    authenticate_buf = b""
                    password_count += 1
                    if password_count > 2:
                        msg = "password prompt seen more than once, assuming auth failed"
                        self.logger.critical(msg)
                        raise ScrapliAuthenticationFailed(msg)
                    self.write(channel_input=auth_password, redacted=True)
                    self.send_return()

                channel_match = re.search(
                    pattern=search_pattern,
                    string=authenticate_buf,
                )

                if channel_match:
                    return

    @ChannelTimeout(message="timed out getting prompt")
    def get_prompt(self) -> str:
        """
        Get current channel prompt

        Args:
            N/A

        Returns:
            str: string of the current prompt

        Raises:
            N/A

        """
        buf = b""

        search_pattern = self._get_prompt_pattern(
            class_pattern=self._base_channel_args.comms_prompt_pattern
        )

        with self._channel_lock():
            self.send_return()

            while True:
                buf += self.read()

                channel_match = re.search(
                    pattern=search_pattern,
                    string=buf,
                )

                if channel_match:
                    current_prompt = channel_match.group(0)
                    return current_prompt.decode().strip()

    @ChannelTimeout(message="timed out sending input to device")
    def send_input(
        self,
        channel_input: str,
        *,
        strip_prompt: bool = True,
        eager: bool = False,
    ) -> Tuple[bytes, bytes]:
        """
        Primary entry point to send data to devices in shell mode; accept input and returns result

        Args:
            channel_input: string input to send to channel
            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)
            eager: eager mode reads and returns the `_read_until_input` value, but does not attempt
                to read to the prompt pattern -- this should not be used manually! (only used by
                `send_configs` with the eager flag set)

        Returns:
            Tuple[bytes, bytes]: tuple of "raw" output and "processed" (cleaned up/stripped) output

        Raises:
            N/A

        """
        self._pre_send_input(channel_input=channel_input)

        buf = b""
        bytes_channel_input = channel_input.encode()

        self.logger.info(
            f"sending channel input: {channel_input}; strip_prompt: {strip_prompt}; eager: {eager}"
        )

        with self._channel_lock():
            self.write(channel_input=channel_input)
            _buf_until_input = self._read_until_input(channel_input=bytes_channel_input)
            self.send_return()

            if not eager:
                buf += self._read_until_prompt()

        processed_buf = self._process_output(
            buf=buf,
            strip_prompt=strip_prompt,
        )
        return buf, processed_buf

    @ChannelTimeout(message="timed out sending input to device")
    def send_input_and_read(
        self,
        channel_input: str,
        *,
        strip_prompt: bool = True,
        expected_outputs: Optional[List[str]] = None,
        read_duration: Optional[float] = None,
    ) -> Tuple[bytes, bytes]:
        """
        Send a command and read until expected prompt is seen, outputs are seen, or for duration

        Args:
            channel_input: string input to send to channel
            strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)
            expected_outputs: list of strings to look for in output; if any of these are seen,
                return output read up till that read
            read_duration: float duration to read for

        Returns:
            Tuple[bytes, bytes]: tuple of "raw" output and "processed" (cleaned up/stripped) output

        Raises:
            N/A

        """
        self._pre_send_input(channel_input=channel_input)

        buf = b""
        bytes_channel_input = channel_input.encode()
        bytes_channel_outputs = [
            channel_output.encode() for channel_output in expected_outputs or []
        ]

        self.logger.info(
            f"sending channel input and read: {channel_input}; strip_prompt: {strip_prompt}; "
            f"expected_outputs: {expected_outputs}; read_duration: {read_duration}"
        )

        with self._channel_lock():
            self.write(channel_input=channel_input)
            _buf_until_input = self._read_until_input(channel_input=bytes_channel_input)
            self.send_return()

            buf += self._read_until_prompt_or_time(
                channel_outputs=bytes_channel_outputs, read_duration=read_duration
            )

        processed_buf = self._process_output(
            buf=buf,
            strip_prompt=strip_prompt,
        )

        return buf, processed_buf

    @ChannelTimeout(message="timed out sending interactive input to device")
    def send_inputs_interact(
        self, interact_events: List[Tuple[str, str, Optional[bool]]]
    ) -> Tuple[bytes, bytes]:
        """
        Interact with a device with changing prompts per input.

        Used to interact with devices where prompts change per input, and where inputs may be hidden
        such as in the case of a password input. This can be used to respond to challenges from
        devices such as the confirmation for the command "clear logging" on IOSXE devices for
        example. You may have as many elements in the "interact_events" list as needed, and each
        element of that list should be a tuple of two or three elements. The first element is always
        the input to send as a string, the second should be the expected response as a string, and
        the optional third a bool for whether or not the input is "hidden" (i.e. password input)

        An example where we need this sort of capability:

        '''
        3560CX#copy flash: scp:
        Source filename []? test1.txt
        Address or name of remote host []? 172.31.254.100
        Destination username [carl]?
        Writing test1.txt
        Password:

        Password:
         Sink: C0644 639 test1.txt
        !
        639 bytes copied in 12.066 secs (53 bytes/sec)
        3560CX#
        '''

        To accomplish this we can use the following:

        '''
        interact = conn.channel.send_inputs_interact(
            [
                ("copy flash: scp:", "Source filename []?", False),
                ("test1.txt", "Address or name of remote host []?", False),
                ("172.31.254.100", "Destination username [carl]?", False),
                ("carl", "Password:", False),
                ("super_secure_password", prompt, True),
            ]
        )
        '''

        If we needed to deal with more prompts we could simply continue adding tuples to the list of
        interact "events".

        Args:
            interact_events: list of tuples containing the "interactions" with the device
                each list element must have an input and an expected response, and may have an
                optional bool for the third and final element -- the optional bool specifies if the
                input that is sent to the device is "hidden" (ex: password), if the hidden param is
                not provided it is assumed the input is "normal" (not hidden)

        Returns:
            Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning,
                and the output read from the channel that has been "cleaned up"

        Raises:
            N/A

        """
        self._pre_send_inputs_interact(interact_events=interact_events)

        buf = b""
        processed_buf = b""

        with self._channel_lock():
            for interact_event in interact_events:
                channel_input = interact_event[0]
                bytes_channel_input = channel_input.encode()
                channel_response = interact_event[1]
                try:
                    hidden_input = interact_event[2]
                except IndexError:
                    hidden_input = False

                _channel_input = channel_input if not hidden_input else "REDACTED"
                self.logger.info(
                    f"sending interactive input: {_channel_input}; "
                    f"expecting: {channel_response}; "
                    f"hidden_input: {hidden_input}"
                )

                self.write(channel_input=channel_input)
                if not channel_response or hidden_input is True:
                    self.send_return()
                else:
                    buf += self._read_until_input(channel_input=bytes_channel_input)
                    self.send_return()
                buf += self._read_until_prompt(prompt=channel_response)

        processed_buf += self._process_output(
            buf=buf,
            strip_prompt=False,
        )

        return buf, processed_buf
        </code>
    </pre>
</details>

<h4 id="ancestors-in-mro">Ancestors (in MRO)<a class="headerlink" href="#ancestors-in-mro" title="Permanent link">&para;</a></h4>
<ul>
<li>scrapli.channel.base_channel.BaseChannel</li>
</ul>
<h4 id="methods">Methods<a class="headerlink" href="#methods" title="Permanent link">&para;</a></h4>
<h5 id="channel_authenticate_ssh">channel_authenticate_ssh<a class="headerlink" href="#channel_authenticate_ssh" title="Permanent link">&para;</a></h5>
<p><code>channel_authenticate_ssh(self, auth_password:str, auth_private_key_passphrase:str) &gt; NoneType</code></p>
<div class="text codehilite"><pre><span></span><code>Handle SSH Authentication for transports that only operate &quot;in the channel&quot; (i.e. system)

Args:
    auth_password: password to authenticate with
    auth_private_key_passphrase: passphrase for ssh key if necessary

Returns:
    None

Raises:
    ScrapliAuthenticationFailed: if password prompt seen more than twice
    ScrapliAuthenticationFailed: if passphrase prompt seen more than twice
</code></pre></div>

<h5 id="channel_authenticate_telnet">channel_authenticate_telnet<a class="headerlink" href="#channel_authenticate_telnet" title="Permanent link">&para;</a></h5>
<p><code>channel_authenticate_telnet(self, auth_username:str='', auth_password:str='') &gt; NoneType</code></p>
<div class="text codehilite"><pre><span></span><code>Handle Telnet Authentication

Args:
    auth_username: username to use for telnet authentication
    auth_password: password to use for telnet authentication

Returns:
    None

Raises:
    ScrapliAuthenticationFailed: if password prompt seen more than twice
    ScrapliAuthenticationFailed: if login prompt seen more than twice
</code></pre></div>

<h5 id="get_prompt">get_prompt<a class="headerlink" href="#get_prompt" title="Permanent link">&para;</a></h5>
<p><code>get_prompt(self) &gt; str</code></p>
<div class="text codehilite"><pre><span></span><code>Get current channel prompt

Args:
    N/A

Returns:
    str: string of the current prompt

Raises:
    N/A
</code></pre></div>

<h5 id="read">read<a class="headerlink" href="#read" title="Permanent link">&para;</a></h5>
<p><code>read(self) &gt; bytes</code></p>
<div class="text codehilite"><pre><span></span><code>Read chunks of output from the channel

Replaces any r&quot;
&quot; characters that sometimes get stuffed into the output from the devices

Args:
    N/A

Returns:
    bytes: output read from channel

Raises:
    N/A
</code></pre></div>

<h5 id="send_input">send_input<a class="headerlink" href="#send_input" title="Permanent link">&para;</a></h5>
<p><code>send_input(self, channel_input:str, *, strip_prompt:bool=True, eager:bool=False) &gt; Tuple[bytes,bytes]</code></p>
<div class="text codehilite"><pre><span></span><code>Primary entry point to send data to devices in shell mode; accept input and returns result

Args:
    channel_input: string input to send to channel
    strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)
    eager: eager mode reads and returns the `_read_until_input` value, but does not attempt
        to read to the prompt pattern -- this should not be used manually! (only used by
        `send_configs` with the eager flag set)

Returns:
    Tuple[bytes, bytes]: tuple of &quot;raw&quot; output and &quot;processed&quot; (cleaned up/stripped) output

Raises:
    N/A
</code></pre></div>

<h5 id="send_input_and_read">send_input_and_read<a class="headerlink" href="#send_input_and_read" title="Permanent link">&para;</a></h5>
<p><code>send_input_and_read(self, channel_input:str, *, strip_prompt:bool=True, expected_outputs:Union[List[str],NoneType]=None, read_duration:Union[float,NoneType]=None) &gt; Tuple[bytes,bytes]</code></p>
<div class="text codehilite"><pre><span></span><code>Send a command and read until expected prompt is seen, outputs are seen, or for duration

Args:
    channel_input: string input to send to channel
    strip_prompt: strip prompt or not, defaults to True (yes, strip the prompt)
    expected_outputs: list of strings to look for in output; if any of these are seen,
        return output read up till that read
    read_duration: float duration to read for

Returns:
    Tuple[bytes, bytes]: tuple of &quot;raw&quot; output and &quot;processed&quot; (cleaned up/stripped) output

Raises:
    N/A
</code></pre></div>

<h5 id="send_inputs_interact">send_inputs_interact<a class="headerlink" href="#send_inputs_interact" title="Permanent link">&para;</a></h5>
<p><code>send_inputs_interact(self, interact_events:List[Tuple[str,str,Union[bool,NoneType]]]) &gt; Tuple[bytes,bytes]</code></p>
<div class="text codehilite"><pre><span></span><code>Interact with a device with changing prompts per input.

Used to interact with devices where prompts change per input, and where inputs may be hidden
such as in the case of a password input. This can be used to respond to challenges from
devices such as the confirmation for the command &quot;clear logging&quot; on IOSXE devices for
example. You may have as many elements in the &quot;interact_events&quot; list as needed, and each
element of that list should be a tuple of two or three elements. The first element is always
the input to send as a string, the second should be the expected response as a string, and
the optional third a bool for whether or not the input is &quot;hidden&quot; (i.e. password input)

An example where we need this sort of capability:

&#39;&#39;&#39;
3560CX#copy flash: scp:
Source filename []? test1.txt
Address or name of remote host []? 172.31.254.100
Destination username [carl]?
Writing test1.txt
Password:

Password:
 Sink: C0644 639 test1.txt
!
639 bytes copied in 12.066 secs (53 bytes/sec)
3560CX#
&#39;&#39;&#39;

To accomplish this we can use the following:

&#39;&#39;&#39;
interact = conn.channel.send_inputs_interact(
    [
        (&quot;copy flash: scp:&quot;, &quot;Source filename []?&quot;, False),
        (&quot;test1.txt&quot;, &quot;Address or name of remote host []?&quot;, False),
        (&quot;172.31.254.100&quot;, &quot;Destination username [carl]?&quot;, False),
        (&quot;carl&quot;, &quot;Password:&quot;, False),
        (&quot;super_secure_password&quot;, prompt, True),
    ]
)
&#39;&#39;&#39;

If we needed to deal with more prompts we could simply continue adding tuples to the list of
interact &quot;events&quot;.

Args:
    interact_events: list of tuples containing the &quot;interactions&quot; with the device
        each list element must have an input and an expected response, and may have an
        optional bool for the third and final element -- the optional bool specifies if the
        input that is sent to the device is &quot;hidden&quot; (ex: password), if the hidden param is
        not provided it is assumed the input is &quot;normal&quot; (not hidden)

Returns:
    Tuple[bytes, bytes]: output read from the channel with no whitespace trimming/cleaning,
        and the output read from the channel that has been &quot;cleaned up&quot;

Raises:
    N/A
</code></pre></div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../base_channel/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Base Channel
              </div>
            </div>
          </a>
        
        
          <a href="../async_channel/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Async Channel
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
  <div class="md-footer-social">
    
      
      
        
        
      
      <a href="https://github.com/carlmontanari/scrapli" target="_blank" rel="noopener" title="github.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
      </a>
    
      
      
        
        
      
      <a href="https://twitter.com/carlrmontanari" target="_blank" rel="noopener" title="twitter.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
      </a>
    
      
      
        
        
      
      <a href="https://www.linkedin.com/in/carl-montanari-47888931/" target="_blank" rel="noopener" title="www.linkedin.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
      </a>
    
      
      
        
        
      
      <a href="https://montanari.io" target="_blank" rel="noopener" title="montanari.io" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M336.5 160C322 70.7 287.8 8 248 8s-74 62.7-88.5 152h177zM152 256c0 22.2 1.2 43.5 3.3 64h185.3c2.1-20.5 3.3-41.8 3.3-64s-1.2-43.5-3.3-64H155.3c-2.1 20.5-3.3 41.8-3.3 64zm324.7-96c-28.6-67.9-86.5-120.4-158-141.6 24.4 33.8 41.2 84.7 50 141.6h108zM177.2 18.4C105.8 39.6 47.8 92.1 19.3 160h108c8.7-56.9 25.5-107.8 49.9-141.6zM487.4 192H372.7c2.1 21 3.3 42.5 3.3 64s-1.2 43-3.3 64h114.6c5.5-20.5 8.6-41.8 8.6-64s-3.1-43.5-8.5-64zM120 256c0-21.5 1.2-43 3.3-64H8.6C3.2 212.5 0 233.8 0 256s3.2 43.5 8.6 64h114.6c-2-21-3.2-42.5-3.2-64zm39.5 96c14.5 89.3 48.7 152 88.5 152s74-62.7 88.5-152h-177zm159.3 141.6c71.4-21.2 129.4-73.7 158-141.6h-108c-8.8 56.9-25.6 107.8-50 141.6zM19.3 352c28.6 67.9 86.5 120.4 158 141.6-24.4-33.8-41.2-84.7-50-141.6h-108z"/></svg>
      </a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../assets/javascripts/vendor.93c04032.min.js"></script>
      <script src="../../../assets/javascripts/bundle.83e5331e.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../../..",
          features: [],
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.8c7e0a7e.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>